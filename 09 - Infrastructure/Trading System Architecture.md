# Trading System Architecture

A robust trading system is a complex, distributed software application designed to handle market data ingestion, signal calculation, risk management, and order execution with high reliability and low latency.

---

## 1. High-Level Modular Design

A production-grade system is typically divided into several decoupled components:

### A. Market Data Handler (Ingestor)
Connects to external feeds (Websockets, FIX, Direct Multicast).
- **Responsibility:** Normalization (converting vendor JSON/Binary to internal Protobuf/Flatbuffers).
- **Crucial Feature:** Timestamping at the point of arrival (Network Interface Card).

### B. Strategy Engine (The "Brain")
Consumes normalized data and generates signals.
- **Logic:** Technical indicators, ML models, or arbitrage math.
- **State Management:** Tracks current positions and P&L in memory.

### C. Risk Engine (The "Gatekeeper")
Every order generated by the strategy MUST pass through risk checks.
- **Checks:** Maximum position size, max leverage, "fat-finger" price limits, daily loss limits.
- **Speed:** Must be extremely fast (pre-calculated limits).

### D. Order Management System (OMS) / Execution Gateway
Handles the "lifecycle" of an order.
- **Tasks:** Routing to specific venues, tracking fills, handling partial fills, cancels, and replaces.
- **Protocol:** Usually talks **FIX** or exchange-native binary protocols.

### E. Database / Log Sink
Records everything for post-trade analysis.
- **Storage:** Tick-by-tick market data and all internal system events (Order Events, Fill Events).

---

## 2. Event-Driven vs. Polling

- **Event-Driven (Standard):** The system reacts to "events" (e.g., `OnTick`, `OnOrderFill`). Minimizes idle time and latency.
- **Polling (Avoid):** Checking the price every $X$ milliseconds. Inefficient and adds unnecessary lag.

---

## 3. Communication Patterns

How components talk to each other:
- **ZeroMQ / NanoMsg:** Low-latency messaging patterns (PUB/SUB for market data, PUSH/PULL for orders).
- **Shared Memory:** For ultra-low latency (HFT), different processes read/write to the same memory segment to avoid network overhead.

---

## 4. The "Hot Path" Optimization

The **Hot Path** is the sequence of code that runs between receiving a market tick and sending an order. To minimize latency:
- **Avoid Allocation:** No memory allocation (GC spikes) in the hot path. Use object pools.
- **CPU Pinning:** Lock the strategy thread to a specific CPU core to avoid context switching.
- **Lock-Free Queues:** Use atomic operations instead of mutexes for communication.

---

## 5. Failover and Reliability

- **Heartbeats:** Components check if others are still alive.
- **State Recovery:** If the strategy crashes, it must be able to rebuild its position state from the Execution Gateway logs upon restart.

---

## Related Notes
- [[Infrastructure MOC]] — Broader context
- [[Low-Latency Systems]] — Software optimizations
- [[High-Frequency Trading Infrastructure]] — The extreme end
- [[FIX Protocol]] — Communication standard
- [[Real-Time Data Pipelines]] — Data flow
- [[Database Design for Trading]] — Storage layer
- [[Monitoring and Alerting]] — (To be created) Keeping it running
